# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Adrian Liaw <adrianliaw2000@gmail.com>, 2018
# Dr-XYZ <dr.xyz.tw@gmail.com>, 2025
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-03-09 00:13+0000\n"
"PO-Revision-Date: 2025-06-26 20:00+0800\n"
"Last-Translator: Dr-XYZ <dr.xyz.tw@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/zipfile.rst:2
msgid ":mod:`!zipfile` --- Work with ZIP archives"
msgstr ":mod:`!zipfile` --- 處理 ZIP 封存檔案"

#: ../../library/zipfile.rst:10
msgid "**Source code:** :source:`Lib/zipfile/`"
msgstr "**原始碼：**\\ :source:`Lib/zipfile/`"

#: ../../library/zipfile.rst:14
msgid ""
"The ZIP file format is a common archive and compression standard. This "
"module provides tools to create, read, write, append, and list a ZIP file.  "
"Any advanced use of this module will require an understanding of the format, "
"as defined in `PKZIP Application Note`_."
msgstr ""
"ZIP 檔案格式是一種常見的封存與壓縮標準。本模組提供了建立、讀取、寫入、附加與"
"列出 ZIP 檔案的工具。任何對本模組的進階使用都將需要對 `PKZIP Application "
"Note`_ 中定義的格式有所理解。"

#: ../../library/zipfile.rst:19
msgid ""
"This module does not currently handle multi-disk ZIP files. It can handle "
"ZIP files that use the ZIP64 extensions (that is ZIP files that are more "
"than 4 GiB in size).  It supports decryption of encrypted files in ZIP "
"archives, but it currently cannot create an encrypted file.  Decryption is "
"extremely slow as it is implemented in native Python rather than C."
msgstr ""
"本模組目前不處理多磁碟 ZIP 檔案。它可以處理使用 ZIP64 擴充（即大於 4 GiB 的 "
"ZIP 檔案）的 ZIP 檔案。它支援解密 ZIP 封存檔案中的加密檔案，但目前無法建立加"
"密檔案。解密速度極慢，因為它是在原生 Python 中實作，而不是 C。"

#: ../../library/zipfile.rst:26
msgid "The module defines the following items:"
msgstr "本模組定義了以下項目："

#: ../../library/zipfile.rst:30
msgid "The error raised for bad ZIP files."
msgstr "對於損壞的 ZIP 檔案所引發的錯誤。"

#: ../../library/zipfile.rst:37
msgid ""
"Alias of :exc:`BadZipFile`, for compatibility with older Python versions."
msgstr ":exc:`BadZipFile` 的別名，為了與舊版 Python 相容。"

#: ../../library/zipfile.rst:44
msgid ""
"The error raised when a ZIP file would require ZIP64 functionality but that "
"has not been enabled."
msgstr "當 ZIP 檔案需要 ZIP64 功能但該功能未被啟用時所引發的錯誤。"

#: ../../library/zipfile.rst:51
msgid ""
"The class for reading and writing ZIP files.  See section :ref:`zipfile-"
"objects` for constructor details."
msgstr ""
"用於讀取和寫入 ZIP 檔案的類別。有關建構函式的詳細資訊，請參閱 :ref:`zipfile-"
"objects` 章節。"

#: ../../library/zipfile.rst:58
msgid ""
"Class that implements a subset of the interface provided by :class:`pathlib."
"Path`, including the full :class:`importlib.resources.abc.Traversable` "
"interface."
msgstr ""
"實作了 :class:`pathlib.Path` 所提供介面子集的類別，包括完整的 :class:"
"`importlib.resources.abc.Traversable` 介面。"

#: ../../library/zipfile.rst:68
msgid "Class for creating ZIP archives containing Python libraries."
msgstr "用於建立包含 Python 函式庫的 ZIP 封存檔案的類別。"

#: ../../library/zipfile.rst:73
msgid ""
"Class used to represent information about a member of an archive. Instances "
"of this class are returned by the :meth:`.getinfo` and :meth:`.infolist` "
"methods of :class:`ZipFile` objects.  Most users of the :mod:`zipfile` "
"module will not need to create these, but only use those created by this "
"module. *filename* should be the full name of the archive member, and "
"*date_time* should be a tuple containing six fields which describe the time "
"of the last modification to the file; the fields are described in section :"
"ref:`zipinfo-objects`."
msgstr ""
"用於表示封存檔案中成員資訊的類別。此類別的實例由 :class:`ZipFile` 物件的 :"
"meth:`.getinfo` 和 :meth:`.infolist` 方法回傳。大多數 :mod:`zipfile` 模組的使"
"用者不需要建立這些實例，而只需使用本模組所建立的。*filename* 應為封存成員的完"
"整名稱，而 *date_time* 應為一個包含六個欄位的元組，用以描述檔案的最後修改時"
"間；這些欄位在 :ref:`zipinfo-objects` 章節中有所描述。"

#: ../../library/zipfile.rst:82
msgid ""
"A public :attr:`!compress_level` attribute has been added to expose the "
"formerly protected :attr:`!_compresslevel`.  The older protected name "
"continues to work as a property for backwards compatibility."
msgstr ""
"新增了一個公開的 :attr:`!compress_level` 屬性，以公開先前受保護的 :attr:`!"
"_compresslevel`。為了向後相容，舊的受保護名稱仍可作為一個特性繼續運作。"

#: ../../library/zipfile.rst:89
msgid ""
"Returns ``True`` if *filename* is a valid ZIP file based on its magic "
"number, otherwise returns ``False``.  *filename* may be a file or file-like "
"object too."
msgstr ""
"如果 *filename* 根據其幻數是一個有效的 ZIP 檔案，則回傳 ``True``，否則回傳 "
"``False``。*filename* 也可以是一個檔案或類檔案物件。"

#: ../../library/zipfile.rst:92
msgid "Support for file and file-like objects."
msgstr "支援檔案和類檔案物件。"

#: ../../library/zipfile.rst:98
msgid "The numeric constant for an uncompressed archive member."
msgstr "用於未壓縮封存成員的數值常數。"

#: ../../library/zipfile.rst:103
msgid ""
"The numeric constant for the usual ZIP compression method.  This requires "
"the :mod:`zlib` module."
msgstr "用於常用的 ZIP 壓縮方法的數值常數。這需要 :mod:`zlib` 模組。"

#: ../../library/zipfile.rst:109
msgid ""
"The numeric constant for the BZIP2 compression method.  This requires the :"
"mod:`bz2` module."
msgstr "用於 BZIP2 壓縮方法的數值常數。這需要 :mod:`bz2` 模組。"

#: ../../library/zipfile.rst:116
msgid ""
"The numeric constant for the LZMA compression method.  This requires the :"
"mod:`lzma` module."
msgstr "用於 LZMA 壓縮方法的數值常數。這需要 :mod:`lzma` 模組。"

#: ../../library/zipfile.rst:123
msgid ""
"The ZIP file format specification has included support for bzip2 compression "
"since 2001, and for LZMA compression since 2006. However, some tools "
"(including older Python releases) do not support these compression methods, "
"and may either refuse to process the ZIP file altogether, or fail to extract "
"individual files."
msgstr ""
"ZIP 檔案格式規範自 2001 年起已包含對 bzip2 壓縮的支援，並自 2006 年起支援 "
"LZMA 壓縮。然而，某些工具（包括舊版的 Python）不支援這些壓縮方法，可能會完全"
"拒絕處理該 ZIP 檔案，或無法解壓縮個別檔案。"

#: ../../library/zipfile.rst:132
msgid "`PKZIP Application Note`_"
msgstr "`PKZIP Application Note`_"

#: ../../library/zipfile.rst:133
msgid ""
"Documentation on the ZIP file format by Phil Katz, the creator of the format "
"and algorithms used."
msgstr ""
"由 Phil Katz（該格式與所用演算法的創造者）所撰寫的關於 ZIP 檔案格式的文件。"

#: ../../library/zipfile.rst:136
msgid "`Info-ZIP Home Page <https://infozip.sourceforge.net/>`_"
msgstr "`Info-ZIP 首頁 <https://infozip.sourceforge.net/>`_"

#: ../../library/zipfile.rst:137
msgid ""
"Information about the Info-ZIP project's ZIP archive programs and "
"development libraries."
msgstr "關於 Info-ZIP 專案的 ZIP 封存程式和開發函式庫的資訊。"

#: ../../library/zipfile.rst:144
msgid "ZipFile Objects"
msgstr "ZipFile 物件"

#: ../../library/zipfile.rst:151
msgid ""
"Open a ZIP file, where *file* can be a path to a file (a string), a file-"
"like object or a :term:`path-like object`."
msgstr ""
"開啟一個 ZIP 檔案，其中 *file* 可以是一個檔案的路徑（一個字串）、一個類檔案物"
"件或一個 :term:`path-like object`。"

#: ../../library/zipfile.rst:154
msgid ""
"The *mode* parameter should be ``'r'`` to read an existing file, ``'w'`` to "
"truncate and write a new file, ``'a'`` to append to an existing file, or "
"``'x'`` to exclusively create and write a new file. If *mode* is ``'x'`` and "
"*file* refers to an existing file, a :exc:`FileExistsError` will be raised. "
"If *mode* is ``'a'`` and *file* refers to an existing ZIP file, then "
"additional files are added to it.  If *file* does not refer to a ZIP file, "
"then a new ZIP archive is appended to the file.  This is meant for adding a "
"ZIP archive to another file (such as :file:`python.exe`).  If *mode* is "
"``'a'`` and the file does not exist at all, it is created. If *mode* is "
"``'r'`` or ``'a'``, the file should be seekable."
msgstr ""
"*mode* 參數應為 ``'r'`` 來讀取一個現有檔案、``'w'`` 來清空並寫入一個新檔案、"
"``'a'`` 來附加到一個現有檔案，或 ``'x'`` 來獨佔性地建立並寫入一個新檔案。如"
"果 *mode* 為 ``'x'`` 且 *file* 指向一個現有檔案，將會引發 :exc:"
"`FileExistsError`。如果 *mode* 為 ``'a'`` 且 *file* 指向一個現有的 ZIP 檔案，"
"則會將額外的檔案加入其中。如果 *file* 並非指向一個 ZIP 檔案，則一個新的 ZIP "
"封存檔案會被附加到該檔案之後。這適用於將一個 ZIP 封存檔案附加到另一個檔案（例"
"如 :file:`python.exe`）。如果 *mode* 為 ``'a'`` 且檔案完全不存在，它會被建"
"立。如果 *mode* 為 ``'r'`` 或 ``'a'``，該檔案應為可定位的 (seekable)。"

#: ../../library/zipfile.rst:166
msgid ""
"*compression* is the ZIP compression method to use when writing the archive, "
"and should be :const:`ZIP_STORED`, :const:`ZIP_DEFLATED`, :const:`ZIP_BZIP2` "
"or :const:`ZIP_LZMA`; unrecognized values will cause :exc:"
"`NotImplementedError` to be raised.  If :const:`ZIP_DEFLATED`, :const:"
"`ZIP_BZIP2` or :const:`ZIP_LZMA` is specified but the corresponding module (:"
"mod:`zlib`, :mod:`bz2` or :mod:`lzma`) is not available, :exc:`RuntimeError` "
"is raised. The default is :const:`ZIP_STORED`."
msgstr ""
"*compression* 是寫入封存檔案時要使用的 ZIP 壓縮方法，應為 :const:"
"`ZIP_STORED`、:const:`ZIP_DEFLATED`、:const:`ZIP_BZIP2` 或 :const:"
"`ZIP_LZMA`；無法識別的值將導致引發 :exc:`NotImplementedError`。如果指定了 :"
"const:`ZIP_DEFLATED`、:const:`ZIP_BZIP2` 或 :const:`ZIP_LZMA`，但對應的模組"
"（:mod:`zlib`、:mod:`bz2` 或 :mod:`lzma`）不可用，則會引發 :exc:"
"`RuntimeError`。預設為 :const:`ZIP_STORED`。"

#: ../../library/zipfile.rst:174
msgid ""
"If *allowZip64* is ``True`` (the default) zipfile will create ZIP files that "
"use the ZIP64 extensions when the zipfile is larger than 4 GiB. If it is "
"``false`` :mod:`zipfile` will raise an exception when the ZIP file would "
"require ZIP64 extensions."
msgstr ""
"如果 *allowZip64* 為 ``True``\\ （預設值），當 zipfile 大於 4 GiB 時，"
"zipfile 將會建立使用 ZIP64 擴充的 ZIP 檔案。如果為 ``false``，當 ZIP 檔案需"
"要 ZIP64 擴充時，:mod:`zipfile` 將會引發一個例外。"

#: ../../library/zipfile.rst:179
msgid ""
"The *compresslevel* parameter controls the compression level to use when "
"writing files to the archive. When using :const:`ZIP_STORED` or :const:"
"`ZIP_LZMA` it has no effect. When using :const:`ZIP_DEFLATED` integers ``0`` "
"through ``9`` are accepted (see :class:`zlib <zlib.compressobj>` for more "
"information). When using :const:`ZIP_BZIP2` integers ``1`` through ``9`` are "
"accepted (see :class:`bz2 <bz2.BZ2File>` for more information)."
msgstr ""
"*compresslevel* 參數控制寫入檔案到封存時使用的壓縮層級。當使用 :const:"
"`ZIP_STORED` 或 :const:`ZIP_LZMA` 時，它沒有效果。當使用 :const:"
"`ZIP_DEFLATED` 時，接受整數 ``0`` 到 ``9``\\ （更多資訊請參閱 :class:`zlib "
"<zlib.compressobj>`）。當使用 :const:`ZIP_BZIP2` 時，接受整數 ``1`` 到 ``9``"
"\\ （更多資訊請參閱 :class:`bz2 <bz2.BZ2File>`）。"

#: ../../library/zipfile.rst:187 ../../library/zipfile.rst:768
msgid ""
"The *strict_timestamps* argument, when set to ``False``, allows to zip files "
"older than 1980-01-01 at the cost of setting the timestamp to 1980-01-01. "
"Similar behavior occurs with files newer than 2107-12-31, the timestamp is "
"also set to the limit."
msgstr ""
"*strict_timestamps* 引數，當設為 ``False`` 時，允許壓縮早於 1980-01-01 的檔"
"案，代價是將時間戳記設為 1980-01-01。對於晚於 2107-12-31 的檔案，也會有類似的"
"行為，時間戳記同樣會被設為極限值。"

#: ../../library/zipfile.rst:193
msgid ""
"When mode is ``'r'``, *metadata_encoding* may be set to the name of a codec, "
"which will be used to decode metadata such as the names of members and ZIP "
"comments."
msgstr ""
"當 mode 為 ``'r'`` 時，*metadata_encoding* 可以設為一個編解碼器的名稱，該編解"
"碼器將被用來解碼元資料，例如成員名稱和 ZIP 註解。"

#: ../../library/zipfile.rst:197
msgid ""
"If the file is created with mode ``'w'``, ``'x'`` or ``'a'`` and then :meth:"
"`closed <close>` without adding any files to the archive, the appropriate "
"ZIP structures for an empty archive will be written to the file."
msgstr ""
"如果檔案以 ``'w'``、``'x'`` 或 ``'a'`` 模式建立，然後在沒有向封存檔案中加入任"
"何檔案的情況下 :meth:`關閉 <close>`，則適用於空封存檔案的 ZIP 結構將被寫入檔"
"案中。"

#: ../../library/zipfile.rst:201
msgid ""
"ZipFile is also a context manager and therefore supports the :keyword:`with` "
"statement.  In the example, *myzip* is closed after the :keyword:`!with` "
"statement's suite is finished---even if an exception occurs::"
msgstr ""
"ZipFile 也是一個情境管理器，因此支援 :keyword:`with` 陳述式。在範例中，"
"*myzip* 在 :keyword:`!with` 陳述式的程式碼區塊執行完畢後會被關閉 --- 即使發生"
"例外也是如此： ::"

#: ../../library/zipfile.rst:205
msgid ""
"with ZipFile('spam.zip', 'w') as myzip:\n"
"    myzip.write('eggs.txt')"
msgstr ""
"with ZipFile('spam.zip', 'w') as myzip:\n"
"    myzip.write('eggs.txt')"

#: ../../library/zipfile.rst:210
msgid ""
"*metadata_encoding* is an instance-wide setting for the ZipFile. It is not "
"currently possible to set this on a per-member basis."
msgstr ""
"*metadata_encoding* 是 ZipFile 的一個實例範圍設定。目前無法以每個成員為基礎來"
"設定此項。"

#: ../../library/zipfile.rst:213
msgid ""
"This attribute is a workaround for legacy implementations which produce "
"archives with names in the current locale encoding or code page (mostly on "
"Windows).  According to the .ZIP standard, the encoding of metadata may be "
"specified to be either IBM code page (default) or UTF-8 by a flag in the "
"archive header. That flag takes precedence over *metadata_encoding*, which "
"is a Python-specific extension."
msgstr ""
"此屬性是針對舊版實作的變通方法，這些實作會以當前地區編碼或字碼頁（主要在 "
"Windows 上）產生帶有名稱的封存檔案。根據 .ZIP 標準，元資料的編碼可以透過封存"
"檔案標頭中的一個旗標指定為 IBM 字碼頁（預設）或 UTF-8。該旗標的優先級高於 "
"*metadata_encoding*，後者是 Python 特有的擴充。"

#: ../../library/zipfile.rst:221
msgid "Added the ability to use :class:`ZipFile` as a context manager."
msgstr "新增 :class:`ZipFile` 作為情境管理器使用的能力。"

#: ../../library/zipfile.rst:224
msgid "Added support for :mod:`bzip2 <bz2>` and :mod:`lzma` compression."
msgstr "新增對於 :mod:`bzip2 <bz2>` 和 :mod:`lzma` 壓縮的支援。"

#: ../../library/zipfile.rst:227 ../../library/zipfile.rst:681
msgid "ZIP64 extensions are enabled by default."
msgstr "ZIP64 擴充預設為啟用。"

#: ../../library/zipfile.rst:230
msgid ""
"Added support for writing to unseekable streams. Added support for the "
"``'x'`` mode."
msgstr ""
"新增了對寫入不可定位的 (unseekable) 串流的支援。新增了對 ``'x'`` 模式的支援。"

#: ../../library/zipfile.rst:234
msgid ""
"Previously, a plain :exc:`RuntimeError` was raised for unrecognized "
"compression values."
msgstr "先前，對於無法識別的壓縮值，會引發一個單純的 :exc:`RuntimeError`。"

#: ../../library/zipfile.rst:238
msgid "The *file* parameter accepts a :term:`path-like object`."
msgstr "*file* 參數接受一個 :term:`path-like object`。"

#: ../../library/zipfile.rst:241
msgid "Add the *compresslevel* parameter."
msgstr "新增 *compresslevel* 參數。"

#: ../../library/zipfile.rst:244
msgid "The *strict_timestamps* keyword-only parameter."
msgstr "*strict_timestamps* 僅限關鍵字參數。"

#: ../../library/zipfile.rst:247
msgid ""
"Added support for specifying member name encoding for reading metadata in "
"the zipfile's directory and file headers."
msgstr ""
"新增了在讀取 zipfile 目錄和檔案標頭中的元資料時，可指定成員名稱編碼的支援。"

#: ../../library/zipfile.rst:254
msgid ""
"Close the archive file.  You must call :meth:`close` before exiting your "
"program or essential records will not be written."
msgstr ""
"關閉封存檔案。你必須在結束程式前呼叫 :meth:`close`，否則必要的記錄將不會被寫"
"入。"

#: ../../library/zipfile.rst:260
msgid ""
"Return a :class:`ZipInfo` object with information about the archive member "
"*name*.  Calling :meth:`getinfo` for a name not currently contained in the "
"archive will raise a :exc:`KeyError`."
msgstr ""
"回傳一個帶有關於封存成員 *name* 資訊的 :class:`ZipInfo` 物件。對一個目前不包"
"含在封存檔案中的名稱呼叫 :meth:`getinfo` 將會引發 :exc:`KeyError`。"

#: ../../library/zipfile.rst:267
msgid ""
"Return a list containing a :class:`ZipInfo` object for each member of the "
"archive.  The objects are in the same order as their entries in the actual "
"ZIP file on disk if an existing archive was opened."
msgstr ""
"回傳一個串列，其中為每個封存成員包含一個 :class:`ZipInfo` 物件。如果開啟的是"
"一個現有的封存檔案，這些物件的順序與它們在磁碟上實際 ZIP 檔案中的條目順序相"
"同。"

#: ../../library/zipfile.rst:274
msgid "Return a list of archive members by name."
msgstr "依名稱回傳封存成員的串列。"

#: ../../library/zipfile.rst:279
msgid ""
"Access a member of the archive as a binary file-like object.  *name* can be "
"either the name of a file within the archive or a :class:`ZipInfo` object.  "
"The *mode* parameter, if included, must be ``'r'`` (the default) or "
"``'w'``.  *pwd* is the password used to decrypt encrypted ZIP files as a :"
"class:`bytes` object."
msgstr ""
"以二進位類檔案物件的形式存取封存檔案中的一個成員。*name* 可以是封存檔案內的檔"
"案名稱，或是一個 :class:`ZipInfo` 物件。*mode* 參數如果包含，則必須是 ``'r'``"
"\\ （預設值）或 ``'w'``。*pwd* 是用於解密加密 ZIP 檔案的密碼，為一個 :class:"
"`bytes` 物件。"

#: ../../library/zipfile.rst:285
msgid ""
":meth:`~ZipFile.open` is also a context manager and therefore supports the :"
"keyword:`with` statement::"
msgstr ""
":meth:`~ZipFile.open` 也是一個情境管理器，因此支援 :keyword:`with` 陳述"
"式： ::"

#: ../../library/zipfile.rst:288
msgid ""
"with ZipFile('spam.zip') as myzip:\n"
"    with myzip.open('eggs.txt') as myfile:\n"
"        print(myfile.read())"
msgstr ""
"with ZipFile('spam.zip') as myzip:\n"
"    with myzip.open('eggs.txt') as myfile:\n"
"        print(myfile.read())"

#: ../../library/zipfile.rst:292
msgid ""
"With *mode* ``'r'`` the file-like object (``ZipExtFile``) is read-only and "
"provides the following methods: :meth:`~io.BufferedIOBase.read`, :meth:`~io."
"IOBase.readline`, :meth:`~io.IOBase.readlines`, :meth:`~io.IOBase.seek`, :"
"meth:`~io.IOBase.tell`, :meth:`~container.__iter__`, :meth:`~iterator."
"__next__`. These objects can operate independently of the ZipFile."
msgstr ""
"在 *mode* 為 ``'r'`` 時，該類檔案物件（``ZipExtFile``）是唯讀的，並提供以下方"
"法：:meth:`~io.BufferedIOBase.read`、:meth:`~io.IOBase.readline`、:meth:`~io."
"IOBase.readlines`、:meth:`~io.IOBase.seek`、:meth:`~io.IOBase.tell`、:meth:"
"`~container.__iter__`、:meth:`~iterator.__next__`。這些物件可以獨立於 "
"ZipFile 運作。"

#: ../../library/zipfile.rst:299
msgid ""
"With ``mode='w'``, a writable file handle is returned, which supports the :"
"meth:`~io.BufferedIOBase.write` method.  While a writable file handle is "
"open, attempting to read or write other files in the ZIP file will raise a :"
"exc:`ValueError`."
msgstr ""
"在 ``mode='w'`` 時，會回傳一個可寫的檔案控制代碼，它支援 :meth:`~io."
"BufferedIOBase.write` 方法。當一個可寫的檔案控制代碼開啟時，嘗試讀取或寫入 "
"ZIP 檔案中的其他檔案將會引發 :exc:`ValueError`。"

#: ../../library/zipfile.rst:304
msgid ""
"In both cases the file-like object has also attributes :attr:`!name`, which "
"is equivalent to the name of a file within the archive, and :attr:`!mode`, "
"which is ``'rb'`` or ``'wb'`` depending on the input mode."
msgstr ""
"在這兩種情況下，該類檔案物件也具有 :attr:`!name` 屬性，它相當於封存檔案內的檔"
"案名稱，以及 :attr:`!mode` 屬性，其值為 ``'rb'`` 或 ``'wb'``，取決於輸入的模"
"式。"

#: ../../library/zipfile.rst:308
msgid ""
"When writing a file, if the file size is not known in advance but may exceed "
"2 GiB, pass ``force_zip64=True`` to ensure that the header format is capable "
"of supporting large files.  If the file size is known in advance, construct "
"a :class:`ZipInfo` object with :attr:`~ZipInfo.file_size` set, and use that "
"as the *name* parameter."
msgstr ""
"寫入檔案時，如果檔案大小預先未知但可能超過 2 GiB，請傳入 "
"``force_zip64=True`` 以確保標頭格式能夠支援大檔案。如果檔案大小預先已知，請建"
"構一個設定了 :attr:`~ZipInfo.file_size` 的 :class:`ZipInfo` 物件，並將其用作 "
"*name* 參數。"

#: ../../library/zipfile.rst:316
msgid ""
"The :meth:`.open`, :meth:`read` and :meth:`extract` methods can take a "
"filename or a :class:`ZipInfo` object.  You will appreciate this when trying "
"to read a ZIP file that contains members with duplicate names."
msgstr ""
":meth:`.open`、:meth:`read` 和 :meth:`extract` 方法可以接受一個檔名或一個 :"
"class:`ZipInfo` 物件。當你嘗試讀取一個包含重複名稱成員的 ZIP 檔案時，你會發現"
"這很有用。"

#: ../../library/zipfile.rst:320
msgid ""
"Removed support of ``mode='U'``.  Use :class:`io.TextIOWrapper` for reading "
"compressed text files in :term:`universal newlines` mode."
msgstr ""
"移除了對 ``mode='U'`` 的支援。請使用 :class:`io.TextIOWrapper` 以 :term:"
"`universal newlines` 模式讀取壓縮的文字檔。"

#: ../../library/zipfile.rst:324
msgid ""
":meth:`ZipFile.open` can now be used to write files into the archive with "
"the ``mode='w'`` option."
msgstr ""
":meth:`ZipFile.open` 現在可以用於以 ``mode='w'`` 選項將檔案寫入封存檔案。"

#: ../../library/zipfile.rst:328
msgid ""
"Calling :meth:`.open` on a closed ZipFile will raise a :exc:`ValueError`. "
"Previously, a :exc:`RuntimeError` was raised."
msgstr ""
"在一個已關閉的 ZipFile 上呼叫 :meth:`.open` 將會引發 :exc:`ValueError`。先"
"前，會引發一個 :exc:`RuntimeError`。"

#: ../../library/zipfile.rst:332
msgid ""
"Added attributes :attr:`!name` and :attr:`!mode` for the writeable file-like "
"object. The value of the :attr:`!mode` attribute for the readable file-like "
"object was changed from ``'r'`` to ``'rb'``."
msgstr ""
"為可寫的類檔案物件新增了 :attr:`!name` 和 :attr:`!mode` 屬性。可讀的類檔案物"
"件的 :attr:`!mode` 屬性值從 ``'r'`` 變更為 ``'rb'``。"

#: ../../library/zipfile.rst:341
msgid ""
"Extract a member from the archive to the current working directory; *member* "
"must be its full name or a :class:`ZipInfo` object.  Its file information is "
"extracted as accurately as possible.  *path* specifies a different directory "
"to extract to.  *member* can be a filename or a :class:`ZipInfo` object. "
"*pwd* is the password used for encrypted files as a :class:`bytes` object."
msgstr ""
"從封存檔案中解壓縮一個成員到目前工作目錄；*member* 必須是其完整名稱或一個 :"
"class:`ZipInfo` 物件。其檔案資訊會被盡可能精確地解壓縮。*path* 指定一個不同的"
"目錄來解壓縮。*member* 可以是一個檔名或一個 :class:`ZipInfo` 物件。*pwd* 是用"
"於加密檔案的密碼，為一個 :class:`bytes` 物件。"

#: ../../library/zipfile.rst:347
msgid "Returns the normalized path created (a directory or new file)."
msgstr "回傳建立的正規化路徑（一個目錄或新檔案）。"

#: ../../library/zipfile.rst:351
msgid ""
"If a member filename is an absolute path, a drive/UNC sharepoint and leading "
"(back)slashes will be stripped, e.g.: ``///foo/bar`` becomes ``foo/bar`` on "
"Unix, and ``C:\\foo\\bar`` becomes ``foo\\bar`` on Windows. And all ``\".."
"\"`` components in a member filename will be removed, e.g.: ``../../foo../../"
"ba..r`` becomes ``foo../ba..r``.  On Windows illegal characters (``:``, "
"``<``, ``>``, ``|``, ``\"``, ``?``, and ``*``) replaced by underscore "
"(``_``)."
msgstr ""
"如果成員檔名是絕對路徑，磁碟機/UNC 共享點和開頭的（反）斜線將被移除，例如："
"在 Unix 上 ``///foo/bar`` 變成 ``foo/bar``，在 Windows 上 ``C:\\foo\\bar`` 變"
"成 ``foo\\bar``。並且成員檔名中所有的 ``\"..\"`` 元件將被移除，例如：``../../"
"foo../../ba..r`` 變成 ``foo../ba..r``。在 Windows 上，非法字元（``:``、"
"``<``、``>``、``|``、``\"``、``?`` 和 ``*``）會被底線（``_``）取代。"

#: ../../library/zipfile.rst:359
msgid ""
"Calling :meth:`extract` on a closed ZipFile will raise a :exc:`ValueError`.  "
"Previously, a :exc:`RuntimeError` was raised."
msgstr ""
"在一個已關閉的 ZipFile 上呼叫 :meth:`extract` 將會引發 :exc:`ValueError`。先"
"前，會引發一個 :exc:`RuntimeError`。"

#: ../../library/zipfile.rst:363 ../../library/zipfile.rst:386
msgid "The *path* parameter accepts a :term:`path-like object`."
msgstr "*path* 參數接受一個 :term:`path-like object`。"

#: ../../library/zipfile.rst:369
msgid ""
"Extract all members from the archive to the current working directory.  "
"*path* specifies a different directory to extract to.  *members* is optional "
"and must be a subset of the list returned by :meth:`namelist`.  *pwd* is the "
"password used for encrypted files as a :class:`bytes` object."
msgstr ""
"從封存檔案中解壓縮所有成員到目前工作目錄。*path* 指定一個不同的目錄來解壓縮。"
"*members* 是可選的，且必須是 :meth:`namelist` 回傳的串列的子集。*pwd* 是用於"
"加密檔案的密碼，為一個 :class:`bytes` 物件。"

#: ../../library/zipfile.rst:376
msgid ""
"Never extract archives from untrusted sources without prior inspection. It "
"is possible that files are created outside of *path*, e.g. members that have "
"absolute filenames starting with ``\"/\"`` or filenames with two dots ``\".."
"\"``.  This module attempts to prevent that. See :meth:`extract` note."
msgstr ""
"絕不要在未經事先檢查的情況下，從不受信任的來源解壓縮封存檔案。檔案有可能被建"
"立在 *path* 之外，例如，成員具有以 ``\"/\"`` 開頭的絕對檔名或帶有兩個點 ``"
"\"..\"`` 的檔名。本模組會試圖防止這種情況。請參閱 :meth:`extract` 的註解。"

#: ../../library/zipfile.rst:382
msgid ""
"Calling :meth:`extractall` on a closed ZipFile will raise a :exc:"
"`ValueError`.  Previously, a :exc:`RuntimeError` was raised."
msgstr ""
"在一個已關閉的 ZipFile 上呼叫 :meth:`extractall` 將會引發 :exc:`ValueError`。"
"先前，會引發一個 :exc:`RuntimeError`。"

#: ../../library/zipfile.rst:392
msgid "Print a table of contents for the archive to ``sys.stdout``."
msgstr "將封存檔案的內容目錄印出到 ``sys.stdout``。"

#: ../../library/zipfile.rst:397
msgid ""
"Set *pwd* (a :class:`bytes` object) as default password to extract encrypted "
"files."
msgstr "設定 *pwd*\\ （一個 :class:`bytes` 物件）為解壓縮加密檔案的預設密碼。"

#: ../../library/zipfile.rst:402
msgid ""
"Return the bytes of the file *name* in the archive.  *name* is the name of "
"the file in the archive, or a :class:`ZipInfo` object.  The archive must be "
"open for read or append. *pwd* is the password used for encrypted files as "
"a :class:`bytes` object and, if specified, overrides the default password "
"set with :meth:`setpassword`. Calling :meth:`read` on a ZipFile that uses a "
"compression method other than :const:`ZIP_STORED`, :const:`ZIP_DEFLATED`, :"
"const:`ZIP_BZIP2` or :const:`ZIP_LZMA` will raise a :exc:"
"`NotImplementedError`. An error will also be raised if the corresponding "
"compression module is not available."
msgstr ""
"回傳封存檔案中 *name* 檔案的位元組。*name* 是封存檔案中檔案的名稱，或是一個 :"
"class:`ZipInfo` 物件。封存檔案必須以讀取或附加模式開啟。*pwd* 是用於加密檔案"
"的密碼，為一個 :class:`bytes` 物件，如果指定，將會覆寫用 :meth:`setpassword` "
"設定的預設密碼。在一個使用 :const:`ZIP_STORED`、:const:`ZIP_DEFLATED`、:"
"const:`ZIP_BZIP2` 或 :const:`ZIP_LZMA` 以外壓縮方法的 ZipFile 上呼叫 :meth:"
"`read` 將會引發 :exc:`NotImplementedError`。如果對應的壓縮模組不可用，也會引"
"發一個錯誤。"

#: ../../library/zipfile.rst:411
msgid ""
"Calling :meth:`read` on a closed ZipFile will raise a :exc:`ValueError`. "
"Previously, a :exc:`RuntimeError` was raised."
msgstr ""
"在一個已關閉的 ZipFile 上呼叫 :meth:`read` 將會引發 :exc:`ValueError`。先前，"
"會引發一個 :exc:`RuntimeError`。"

#: ../../library/zipfile.rst:418
msgid ""
"Read all the files in the archive and check their CRC's and file headers. "
"Return the name of the first bad file, or else return ``None``."
msgstr ""
"讀取封存檔案中的所有檔案，並檢查它們的 CRC 和檔案標頭。回傳第一個損壞檔案的名"
"稱，否則回傳 ``None``。"

#: ../../library/zipfile.rst:421
msgid ""
"Calling :meth:`testzip` on a closed ZipFile will raise a :exc:`ValueError`.  "
"Previously, a :exc:`RuntimeError` was raised."
msgstr ""
"在一個已關閉的 ZipFile 上呼叫 :meth:`testzip` 將會引發 :exc:`ValueError`。先"
"前，會引發一個 :exc:`RuntimeError`。"

#: ../../library/zipfile.rst:429
msgid ""
"Write the file named *filename* to the archive, giving it the archive name "
"*arcname* (by default, this will be the same as *filename*, but without a "
"drive letter and with leading path separators removed).  If given, "
"*compress_type* overrides the value given for the *compression* parameter to "
"the constructor for the new entry. Similarly, *compresslevel* will override "
"the constructor if given. The archive must be open with mode ``'w'``, "
"``'x'`` or ``'a'``."
msgstr ""
"將名為 *filename* 的檔案寫入封存檔案，並給予它封存名稱 *arcname*（預設情況"
"下，這將與 *filename* 相同，但不含磁碟機代號且移除了開頭的路徑分隔符）。如果"
"給定，*compress_type* 將覆寫為建構函式中 *compression* 參數為新條目指定的值。"
"同樣地，如果給定 *compresslevel*，它將覆寫建構函式。封存檔案必須以 ``'w'``、"
"``'x'`` 或 ``'a'`` 模式開啟。"

#: ../../library/zipfile.rst:439
msgid ""
"The ZIP file standard historically did not specify a metadata encoding, but "
"strongly recommended CP437 (the original IBM PC encoding) for "
"interoperability.  Recent versions allow use of UTF-8 (only).  In this "
"module, UTF-8 will automatically be used to write the member names if they "
"contain any non-ASCII characters.  It is not possible to write member names "
"in any encoding other than ASCII or UTF-8."
msgstr ""
"ZIP 檔案標準在歷史上並未指定元資料編碼，但為了互通性強烈建議使用 CP437（原始"
"的 IBM PC 編碼）。近期的版本允許（僅）使用 UTF-8。在本模組中，如果成員名稱包"
"含任何非 ASCII 字元，將會自動使用 UTF-8 來寫入。無法以 ASCII 或 UTF-8 以外的"
"任何編碼寫入成員名稱。"

#: ../../library/zipfile.rst:448
msgid ""
"Archive names should be relative to the archive root, that is, they should "
"not start with a path separator."
msgstr "封存名稱應相對於封存檔案的根目錄，也就是說，它們不應以路徑分隔符開頭。"

#: ../../library/zipfile.rst:453
msgid ""
"If ``arcname`` (or ``filename``, if ``arcname`` is  not given) contains a "
"null byte, the name of the file in the archive will be truncated at the null "
"byte."
msgstr ""
"如果 ``arcname``\\ （或在未給定 ``arcname`` 時的 ``filename``）包含一個空位元"
"組，封存檔案中該檔案的名稱將在空位元組處被截斷。"

#: ../../library/zipfile.rst:458
msgid ""
"A leading slash in the filename may lead to the archive being impossible to "
"open in some zip programs on Windows systems."
msgstr ""
"檔名中開頭的斜線可能導致在 Windows 系統上的某些 zip 程式中無法開啟該封存檔"
"案。"

#: ../../library/zipfile.rst:461
msgid ""
"Calling :meth:`write` on a ZipFile created with mode ``'r'`` or a closed "
"ZipFile will raise a :exc:`ValueError`.  Previously, a :exc:`RuntimeError` "
"was raised."
msgstr ""
"在以 ``'r'`` 模式建立的 ZipFile 或一個已關閉的 ZipFile 上呼叫 :meth:`write` "
"將會引發 :exc:`ValueError`。先前，會引發一個 :exc:`RuntimeError`。"

#: ../../library/zipfile.rst:470
msgid ""
"Write a file into the archive.  The contents is *data*, which may be either "
"a :class:`str` or a :class:`bytes` instance; if it is a :class:`str`, it is "
"encoded as UTF-8 first.  *zinfo_or_arcname* is either the file name it will "
"be given in the archive, or a :class:`ZipInfo` instance.  If it's an "
"instance, at least the filename, date, and time must be given.  If it's a "
"name, the date and time is set to the current date and time. The archive "
"must be opened with mode ``'w'``, ``'x'`` or ``'a'``."
msgstr ""
"將一個檔案寫入封存檔案。內容為 *data*，它可以是一個 :class:`str` 或一個 :"
"class:`bytes` 實例；如果它是一個 :class:`str`，它會先被編碼為 UTF-8。"
"*zinfo_or_arcname* 是它在封存檔案中將被賦予的檔案名稱，或是一個 :class:"
"`ZipInfo` 實例。如果它是一個實例，則至少必須給定檔名、日期和時間。如果它是一"
"個名稱，則日期和時間被設為目前的日期和時間。封存檔案必須以 ``'w'``、``'x'`` "
"或 ``'a'`` 模式開啟。"

#: ../../library/zipfile.rst:478
msgid ""
"If given, *compress_type* overrides the value given for the *compression* "
"parameter to the constructor for the new entry, or in the *zinfo_or_arcname* "
"(if that is a :class:`ZipInfo` instance). Similarly, *compresslevel* will "
"override the constructor if given."
msgstr ""
"如果給定，*compress_type* 將覆寫為建構函式中 *compression* 參數為新條目指定的"
"值，或覆寫 *zinfo_or_arcname*\\ （如果它是一個 :class:`ZipInfo` 實例）中的"
"值。同樣地，如果給定 *compresslevel*，它將覆寫建構函式。"

#: ../../library/zipfile.rst:485
msgid ""
"When passing a :class:`ZipInfo` instance as the *zinfo_or_arcname* "
"parameter, the compression method used will be that specified in the "
"*compress_type* member of the given :class:`ZipInfo` instance.  By default, "
"the :class:`ZipInfo` constructor sets this member to :const:`ZIP_STORED`."
msgstr ""
"當傳遞一個 :class:`ZipInfo` 實例作為 *zinfo_or_arcname* 參數時，所使用的壓縮"
"方法將是給定的 :class:`ZipInfo` 實例的 *compress_type* 成員中指定的方法。預設"
"情況下，:class:`ZipInfo` 建構函式將此成員設為 :const:`ZIP_STORED`。"

#: ../../library/zipfile.rst:490
msgid "The *compress_type* argument."
msgstr "*compress_type* 引數。"

#: ../../library/zipfile.rst:493
msgid ""
"Calling :meth:`writestr` on a ZipFile created with mode ``'r'`` or a closed "
"ZipFile will raise a :exc:`ValueError`.  Previously, a :exc:`RuntimeError` "
"was raised."
msgstr ""
"在以 ``'r'`` 模式建立的 ZipFile 或一個已關閉的 ZipFile 上呼叫 :meth:"
"`writestr` 將會引發 :exc:`ValueError`。先前，會引發一個 :exc:`RuntimeError`。"

#: ../../library/zipfile.rst:500
msgid ""
"Create a directory inside the archive.  If *zinfo_or_directory* is a string, "
"a directory is created inside the archive with the mode that is specified in "
"the *mode* argument. If, however, *zinfo_or_directory* is a :class:`ZipInfo` "
"instance then the *mode* argument is ignored."
msgstr ""
"在封存檔案內建立一個目錄。如果 *zinfo_or_directory* 是一個字串，則會在封存檔"
"案內以 *mode* 引數中指定的模式建立一個目錄。然而，如果 *zinfo_or_directory* "
"是一個 :class:`ZipInfo` 實例，則 *mode* 引數會被忽略。"

#: ../../library/zipfile.rst:505
msgid "The archive must be opened with mode ``'w'``, ``'x'`` or ``'a'``."
msgstr "封存檔案必須以 ``'w'``、``'x'`` 或 ``'a'`` 模式開啟。"

#: ../../library/zipfile.rst:510
msgid "The following data attributes are also available:"
msgstr "以下資料屬性也可用："

#: ../../library/zipfile.rst:514
msgid "Name of the ZIP file."
msgstr "ZIP 檔案的名稱。"

#: ../../library/zipfile.rst:518
msgid ""
"The level of debug output to use.  This may be set from ``0`` (the default, "
"no output) to ``3`` (the most output).  Debugging information is written to "
"``sys.stdout``."
msgstr ""
"要使用的除錯輸出層級。可以從 ``0``\\ （預設，無輸出）設定到 ``3``\\ （最多輸"
"出）。除錯資訊會被寫入到 ``sys.stdout``。"

#: ../../library/zipfile.rst:524
msgid ""
"The comment associated with the ZIP file as a :class:`bytes` object. If "
"assigning a comment to a :class:`ZipFile` instance created with mode "
"``'w'``, ``'x'`` or ``'a'``, it should be no longer than 65535 bytes.  "
"Comments longer than this will be truncated."
msgstr ""
"與 ZIP 檔案關聯的註解，為一個 :class:`bytes` 物件。如果為一個以 ``'w'``、"
"``'x'`` 或 ``'a'`` 模式建立的 :class:`ZipFile` 實例指派註解，其長度不應超過 "
"65535 位元組。超過此長度的註解將被截斷。"

#: ../../library/zipfile.rst:534
msgid "Path Objects"
msgstr "Path 物件"

#: ../../library/zipfile.rst:538
msgid ""
"Construct a Path object from a ``root`` zipfile (which may be a :class:"
"`ZipFile` instance or ``file`` suitable for passing to the :class:`ZipFile` "
"constructor)."
msgstr ""
"從一個 ``root`` zipfile（它可以是一個 :class:`ZipFile` 實例或一個適合傳遞給 :"
"class:`ZipFile` 建構函式的 ``file``）建構一個 Path 物件。"

#: ../../library/zipfile.rst:542
msgid ""
"``at`` specifies the location of this Path within the zipfile, e.g. 'dir/"
"file.txt', 'dir/', or ''. Defaults to the empty string, indicating the root."
msgstr ""
"``at`` 指定此 Path 在 zipfile 中的位置，例如 'dir/file.txt'、'dir/' 或 ''。預"
"設為空字串，表示根目錄。"

#: ../../library/zipfile.rst:547
msgid ""
"The :class:`Path` class does not sanitize filenames within the ZIP archive. "
"Unlike the :meth:`ZipFile.extract` and :meth:`ZipFile.extractall` methods, "
"it is the caller's responsibility to validate or sanitize filenames to "
"prevent path traversal vulnerabilities (e.g., filenames containing \"..\" or "
"absolute paths). When handling untrusted archives, consider resolving "
"filenames using :func:`os.path.abspath` and checking against the target "
"directory with :func:`os.path.commonpath`."
msgstr ""
":class:`Path` 類別不會清理 ZIP 封存檔案內的檔名。與 :meth:`ZipFile.extract` "
"和 :meth:`ZipFile.extractall` 方法不同，呼叫者有責任驗證或清理檔名，以防止路"
"徑遍歷漏洞（例如，包含 \"..\" 或絕對路徑的檔名）。在處理不受信任的封存檔案"
"時，請考慮使用 :func:`os.path.abspath` 解析檔名，並使用 :func:`os.path."
"commonpath` 與目標目錄進行核對。"

#: ../../library/zipfile.rst:554
msgid ""
"Path objects expose the following features of :mod:`pathlib.Path` objects:"
msgstr "Path 物件公開了 :mod:`pathlib.Path` 物件的以下特性："

#: ../../library/zipfile.rst:557
msgid "Path objects are traversable using the ``/`` operator or ``joinpath``."
msgstr "Path 物件可以使用 ``/`` 運算子或 ``joinpath`` 來遍歷。"

#: ../../library/zipfile.rst:561
msgid "The final path component."
msgstr "最後的路徑元件。"

#: ../../library/zipfile.rst:565
msgid ""
"Invoke :meth:`ZipFile.open` on the current path. Allows opening for read or "
"write, text or binary through supported modes: 'r', 'w', 'rb', 'wb'. "
"Positional and keyword arguments are passed through to :class:`io."
"TextIOWrapper` when opened as text and ignored otherwise. ``pwd`` is the "
"``pwd`` parameter to :meth:`ZipFile.open`."
msgstr ""
"在目前路徑上呼叫 :meth:`ZipFile.open`。允許透過支援的模式 "
"'r'、'w'、'rb'、'wb' 以讀取或寫入、文字或二進位模式開啟。當以文字模式開啟時，"
"位置引數和關鍵字引數會被傳遞給 :class:`io.TextIOWrapper`，否則會被忽略。"
"``pwd`` 是傳遞給 :meth:`ZipFile.open` 的 ``pwd`` 參數。"

#: ../../library/zipfile.rst:574
msgid ""
"Added support for text and binary modes for open. Default mode is now text."
msgstr "新增了對 open 的文字和二進位模式的支援。預設模式現在是文字模式。"

#: ../../library/zipfile.rst:578 ../../library/zipfile.rst:639
msgid ""
"The ``encoding`` parameter can be supplied as a positional argument without "
"causing a :exc:`TypeError`. As it could in 3.9. Code needing to be "
"compatible with unpatched 3.10 and 3.11 versions must pass all :class:`io."
"TextIOWrapper` arguments, ``encoding`` included, as keywords."
msgstr ""
"``encoding`` 參數可以作為位置引數提供，而不會導致 :exc:`TypeError`，就像在 "
"3.9 中一樣。需要與未修補的 3.10 和 3.11 版本相容的程式碼，必須將所有 :class:"
"`io.TextIOWrapper` 引數，包括 ``encoding``，作為關鍵字傳遞。"

#: ../../library/zipfile.rst:586
msgid "Enumerate the children of the current directory."
msgstr "列舉目前目錄的子項目。"

#: ../../library/zipfile.rst:590
msgid "Return ``True`` if the current context references a directory."
msgstr "如果目前情境參照到一個目錄，則回傳 ``True``。"

#: ../../library/zipfile.rst:594
msgid "Return ``True`` if the current context references a file."
msgstr "如果目前情境參照到一個檔案，則回傳 ``True``。"

#: ../../library/zipfile.rst:598
msgid "Return ``True`` if the current context references a symbolic link."
msgstr "如果目前情境參照到一個符號連結，則回傳 ``True``。"

#: ../../library/zipfile.rst:602
msgid "Previously, ``is_symlink`` would unconditionally return ``False``."
msgstr "先前，``is_symlink`` 會無條件地回傳 ``False``。"

#: ../../library/zipfile.rst:607
msgid ""
"Return ``True`` if the current context references a file or directory in the "
"zip file."
msgstr "如果目前情境參照到 zip 檔案中的一個檔案或目錄，則回傳 ``True``。"

#: ../../library/zipfile.rst:612
msgid ""
"The last dot-separated portion of the final component, if any. This is "
"commonly called the file extension."
msgstr "最後一個元件中以點分隔的最後一部分（如果有的話）。這通常被稱為副檔名。"

#: ../../library/zipfile.rst:615
msgid "Added :data:`Path.suffix` property."
msgstr "新增 :data:`Path.suffix` 特性。"

#: ../../library/zipfile.rst:620
msgid "The final path component, without its suffix."
msgstr "最後的路徑元件，不含其後綴。"

#: ../../library/zipfile.rst:622
msgid "Added :data:`Path.stem` property."
msgstr "新增 :data:`Path.stem` 特性。"

#: ../../library/zipfile.rst:627
msgid "A list of the path’s suffixes, commonly called file extensions."
msgstr "路徑的後綴串列，通常稱為副檔名。"

#: ../../library/zipfile.rst:629
msgid "Added :data:`Path.suffixes` property."
msgstr "新增 :data:`Path.suffixes` 特性。"

#: ../../library/zipfile.rst:634
msgid ""
"Read the current file as unicode text. Positional and keyword arguments are "
"passed through to :class:`io.TextIOWrapper` (except ``buffer``, which is "
"implied by the context)."
msgstr ""
"將目前檔案讀取為 unicode 文字。位置引數和關鍵字引數會被傳遞給 :class:`io."
"TextIOWrapper`\\ （除了 ``buffer``，它由情境隱含）。"

#: ../../library/zipfile.rst:647
msgid "Read the current file as bytes."
msgstr "將目前檔案讀取為位元組。"

#: ../../library/zipfile.rst:651
msgid ""
"Return a new Path object with each of the *other* arguments joined. The "
"following are equivalent::"
msgstr "回傳一個新的 Path 物件，並將每個 *other* 引數加入。以下是等效的： ::"

#: ../../library/zipfile.rst:654
msgid ""
">>> Path(...).joinpath('child').joinpath('grandchild')\n"
">>> Path(...).joinpath('child', 'grandchild')\n"
">>> Path(...) / 'child' / 'grandchild'"
msgstr ""
">>> Path(...).joinpath('child').joinpath('grandchild')\n"
">>> Path(...).joinpath('child', 'grandchild')\n"
">>> Path(...) / 'child' / 'grandchild'"

#: ../../library/zipfile.rst:658
msgid ""
"Prior to 3.10, ``joinpath`` was undocumented and accepted exactly one "
"parameter."
msgstr "在 3.10 之前，``joinpath`` 沒有文件記載，且只接受一個參數。"

#: ../../library/zipfile.rst:662
msgid ""
"The :pypi:`zipp` project provides backports of the latest path object "
"functionality to older Pythons. Use ``zipp.Path`` in place of ``zipfile."
"Path`` for early access to changes."
msgstr ""
":pypi:`zipp` 專案為舊版 Python 提供了最新的 path 物件功能的向後移植版本。使"
"用 ``zipp.Path`` 來取代 ``zipfile.Path`` 以提早使用變更。"

#: ../../library/zipfile.rst:670
msgid "PyZipFile Objects"
msgstr "PyZipFile 物件"

#: ../../library/zipfile.rst:672
msgid ""
"The :class:`PyZipFile` constructor takes the same parameters as the :class:"
"`ZipFile` constructor, and one additional parameter, *optimize*."
msgstr ""
":class:`PyZipFile` 建構函式接受與 :class:`ZipFile` 建構函式相同的參數，以及一"
"個額外的參數 *optimize*。"

#: ../../library/zipfile.rst:678
msgid "Added the *optimize* parameter."
msgstr "新增 *optimize* 參數。"

#: ../../library/zipfile.rst:684
msgid ""
"Instances have one method in addition to those of :class:`ZipFile` objects:"
msgstr "實例除了 :class:`ZipFile` 物件的方法之外，還有一個額外的方法："

#: ../../library/zipfile.rst:688
msgid ""
"Search for files :file:`\\*.py` and add the corresponding file to the "
"archive."
msgstr "搜尋 :file:`\\*.py` 檔案，並將對應的檔案加入封存檔案。"

#: ../../library/zipfile.rst:691
msgid ""
"If the *optimize* parameter to :class:`PyZipFile` was not given or ``-1``, "
"the corresponding file is a :file:`\\*.pyc` file, compiling if necessary."
msgstr ""
"如果傳給 :class:`PyZipFile` 的 *optimize* 參數未被給定或為 ``-1``，則對應的檔"
"案是一個 :file:`\\*.pyc` 檔案，如有必要則進行編譯。"

#: ../../library/zipfile.rst:694
msgid ""
"If the *optimize* parameter to :class:`PyZipFile` was ``0``, ``1`` or ``2``, "
"only files with that optimization level (see :func:`compile`) are added to "
"the archive, compiling if necessary."
msgstr ""
"如果傳給 :class:`PyZipFile` 的 *optimize* 參數為 ``0``、``1`` 或 ``2``，則只"
"有具有該最佳化層級（參閱 :func:`compile`）的檔案會被加入封存檔案，如有必要則"
"進行編譯。"

#: ../../library/zipfile.rst:698
msgid ""
"If *pathname* is a file, the filename must end with :file:`.py`, and just "
"the (corresponding :file:`\\*.pyc`) file is added at the top level (no path "
"information).  If *pathname* is a file that does not end with :file:`.py`, "
"a :exc:`RuntimeError` will be raised.  If it is a directory, and the "
"directory is not a package directory, then all the files :file:`\\*.pyc` are "
"added at the top level.  If the directory is a package directory, then all :"
"file:`\\*.pyc` are added under the package name as a file path, and if any "
"subdirectories are package directories, all of these are added recursively "
"in sorted order."
msgstr ""
"如果 *pathname* 是一個檔案，檔名必須以 :file:`.py` 結尾，且只有（對應的 :"
"file:`\\*.pyc`）檔案會被加到頂層（沒有路徑資訊）。如果 *pathname* 是一個不"
"以 :file:`.py` 結尾的檔案，將會引發 :exc:`RuntimeError`。如果它是一個目錄，且"
"該目錄不是一個套件目錄，則所有 :file:`\\*.pyc` 檔案都會被加到頂層。如果該目錄"
"是一個套件目錄，則所有 :file:`\\*.pyc` 都會以檔案路徑的形式被加到套件名稱下，"
"且如果任何子目錄是套件目錄，所有這些都會以排序後的順序遞迴地加入。"

#: ../../library/zipfile.rst:708
msgid "*basename* is intended for internal use only."
msgstr "*basename* 僅供內部使用。"

#: ../../library/zipfile.rst:710
msgid ""
"*filterfunc*, if given, must be a function taking a single string argument.  "
"It will be passed each path (including each individual full file path) "
"before it is added to the archive.  If *filterfunc* returns a false value, "
"the path will not be added, and if it is a directory its contents will be "
"ignored.  For example, if our test files are all either in ``test`` "
"directories or start with the string ``test_``, we can use a *filterfunc* to "
"exclude them::"
msgstr ""
"*filterfunc*，如果給定，必須是一個接受單一字串引數的函式。每個路徑（包括每個"
"單獨的完整檔案路徑）在被加入封存檔案之前都會被傳遞給它。如果 *filterfunc* 回"
"傳一個假值，該路徑將不會被加入，且如果它是一個目錄，其內容將被忽略。例如，如"
"果我們的測試檔案要嘛在 ``test`` 目錄中，要嘛以字串 ``test_`` 開頭，我們可以使"
"用一個 *filterfunc* 來排除它們： ::"

#: ../../library/zipfile.rst:718
msgid ""
">>> zf = PyZipFile('myprog.zip')\n"
">>> def notests(s):\n"
"...     fn = os.path.basename(s)\n"
"...     return (not (fn == 'test' or fn.startswith('test_')))\n"
"...\n"
">>> zf.writepy('myprog', filterfunc=notests)"
msgstr ""
">>> zf = PyZipFile('myprog.zip')\n"
">>> def notests(s):\n"
"...     fn = os.path.basename(s)\n"
"...     return (not (fn == 'test' or fn.startswith('test_')))\n"
"...\n"
">>> zf.writepy('myprog', filterfunc=notests)"

#: ../../library/zipfile.rst:725
msgid "The :meth:`writepy` method makes archives with file names like this::"
msgstr ":meth:`writepy` 方法會建立帶有如下檔名的封存檔案： ::"

#: ../../library/zipfile.rst:728
msgid ""
"string.pyc                   # Top level name\n"
"test/__init__.pyc            # Package directory\n"
"test/testall.pyc             # Module test.testall\n"
"test/bogus/__init__.pyc      # Subpackage directory\n"
"test/bogus/myfile.pyc        # Submodule test.bogus.myfile"
msgstr ""
"string.pyc                   # 頂層名稱\n"
"test/__init__.pyc            # 套件目錄\n"
"test/testall.pyc             # 模組 test.testall\n"
"test/bogus/__init__.pyc      # 子套件目錄\n"
"test/bogus/myfile.pyc        # 子模組 test.bogus.myfile"

#: ../../library/zipfile.rst:734
msgid "Added the *filterfunc* parameter."
msgstr "新增 *filterfunc* 參數。"

#: ../../library/zipfile.rst:737
msgid "The *pathname* parameter accepts a :term:`path-like object`."
msgstr "*pathname* 參數接受一個 :term:`path-like object`。"

#: ../../library/zipfile.rst:740
msgid "Recursion sorts directory entries."
msgstr "遞迴會對目錄條目進行排序。"

#: ../../library/zipfile.rst:747
msgid "ZipInfo Objects"
msgstr "ZipInfo 物件"

#: ../../library/zipfile.rst:749
msgid ""
"Instances of the :class:`ZipInfo` class are returned by the :meth:`.getinfo` "
"and :meth:`.infolist` methods of :class:`ZipFile` objects.  Each object "
"stores information about a single member of the ZIP archive."
msgstr ""
":class:`ZipInfo` 類別的實例由 :class:`ZipFile` 物件的 :meth:`.getinfo` 和 :"
"meth:`.infolist` 方法回傳。每個物件儲存關於 ZIP 封存檔案單一成員的資訊。"

#: ../../library/zipfile.rst:753
msgid ""
"There is one classmethod to make a :class:`ZipInfo` instance for a "
"filesystem file:"
msgstr "有一個類別方法可以為檔案系統中的檔案建立一個 :class:`ZipInfo` 實例："

#: ../../library/zipfile.rst:759
msgid ""
"Construct a :class:`ZipInfo` instance for a file on the filesystem, in "
"preparation for adding it to a zip file."
msgstr ""
"為檔案系統上的一個檔案建構一個 :class:`ZipInfo` 實例，為將其加入 zip 檔案做準"
"備。"

#: ../../library/zipfile.rst:762
msgid "*filename* should be the path to a file or directory on the filesystem."
msgstr "*filename* 應為檔案系統上一個檔案或目錄的路徑。"

#: ../../library/zipfile.rst:764
msgid ""
"If *arcname* is specified, it is used as the name within the archive. If "
"*arcname* is not specified, the name will be the same as *filename*, but "
"with any drive letter and leading path separators removed."
msgstr ""
"如果指定了 *arcname*，它將被用作封存檔案內的名稱。如果未指定 *arcname*，名稱"
"將與 *filename* 相同，但會移除任何磁碟機代號和開頭的路徑分隔符。"

#: ../../library/zipfile.rst:776
msgid "The *filename* parameter accepts a :term:`path-like object`."
msgstr "*filename* 參數接受一個 :term:`path-like object`。"

#: ../../library/zipfile.rst:779
msgid "Added the *strict_timestamps* keyword-only parameter."
msgstr "新增了 *strict_timestamps* 僅限關鍵字參數。"

#: ../../library/zipfile.rst:783
msgid "Instances have the following methods and attributes:"
msgstr "實例具有以下方法和屬性："

#: ../../library/zipfile.rst:787
msgid "Return ``True`` if this archive member is a directory."
msgstr "如果此封存成員是一個目錄，則回傳 ``True``。"

#: ../../library/zipfile.rst:789
msgid "This uses the entry's name: directories should always end with ``/``."
msgstr "這會使用條目的名稱：目錄應總是以 ``/`` 結尾。"

#: ../../library/zipfile.rst:796
msgid "Name of the file in the archive."
msgstr "封存檔案中檔案的名稱。"

#: ../../library/zipfile.rst:801
msgid ""
"The time and date of the last modification to the archive member.  This is a "
"tuple of six values:"
msgstr "封存成員的最後修改時間和日期。這是一個包含六個值的元組："

#: ../../library/zipfile.rst:805
msgid "Index"
msgstr "索引"

#: ../../library/zipfile.rst:805
msgid "Value"
msgstr "值"

#: ../../library/zipfile.rst:807
msgid "``0``"
msgstr "``0``"

#: ../../library/zipfile.rst:807
msgid "Year (>= 1980)"
msgstr "年（>= 1980）"

#: ../../library/zipfile.rst:809
msgid "``1``"
msgstr "``1``"

#: ../../library/zipfile.rst:809
msgid "Month (one-based)"
msgstr "月（從 1 開始）"

#: ../../library/zipfile.rst:811
msgid "``2``"
msgstr "``2``"

#: ../../library/zipfile.rst:811
msgid "Day of month (one-based)"
msgstr "日（從 1 開始）"

#: ../../library/zipfile.rst:813
msgid "``3``"
msgstr "``3``"

#: ../../library/zipfile.rst:813
msgid "Hours (zero-based)"
msgstr "時（從 0 開始）"

#: ../../library/zipfile.rst:815
msgid "``4``"
msgstr "``4``"

#: ../../library/zipfile.rst:815
msgid "Minutes (zero-based)"
msgstr "分（從 0 開始）"

#: ../../library/zipfile.rst:817
msgid "``5``"
msgstr "``5``"

#: ../../library/zipfile.rst:817
msgid "Seconds (zero-based)"
msgstr "秒（從 0 開始）"

#: ../../library/zipfile.rst:822
msgid "The ZIP file format does not support timestamps before 1980."
msgstr "ZIP 檔案格式不支援 1980 年以前的時間戳記。"

#: ../../library/zipfile.rst:827
msgid "Type of compression for the archive member."
msgstr "封存成員的壓縮型別。"

#: ../../library/zipfile.rst:832
msgid "Comment for the individual archive member as a :class:`bytes` object."
msgstr "個別封存成員的註解，為一個 :class:`bytes` 物件。"

#: ../../library/zipfile.rst:837
msgid ""
"Expansion field data.  The `PKZIP Application Note`_ contains some comments "
"on the internal structure of the data contained in this :class:`bytes` "
"object."
msgstr ""
"擴充欄位資料。`PKZIP Application Note`_ 包含一些關於此 :class:`bytes` 物件中"
"所含資料內部結構的註解。"

#: ../../library/zipfile.rst:844
msgid "System which created ZIP archive."
msgstr "建立 ZIP 封存檔案的系統。"

#: ../../library/zipfile.rst:849
msgid "PKZIP version which created ZIP archive."
msgstr "建立 ZIP 封存檔案的 PKZIP 版本。"

#: ../../library/zipfile.rst:854
msgid "PKZIP version needed to extract archive."
msgstr "解壓縮封存檔案所需的 PKZIP 版本。"

#: ../../library/zipfile.rst:859
msgid "Must be zero."
msgstr "必須為零。"

#: ../../library/zipfile.rst:864
msgid "ZIP flag bits."
msgstr "ZIP 旗標位元。"

#: ../../library/zipfile.rst:869
msgid "Volume number of file header."
msgstr "檔案標頭的磁碟區編號。"

#: ../../library/zipfile.rst:874
msgid "Internal attributes."
msgstr "內部屬性。"

#: ../../library/zipfile.rst:879
msgid "External file attributes."
msgstr "外部檔案屬性。"

#: ../../library/zipfile.rst:884
msgid "Byte offset to the file header."
msgstr "到檔案標頭的位元組偏移量。"

#: ../../library/zipfile.rst:889
msgid "CRC-32 of the uncompressed file."
msgstr "未壓縮檔案的 CRC-32。"

#: ../../library/zipfile.rst:894
msgid "Size of the compressed data."
msgstr "壓縮資料的大小。"

#: ../../library/zipfile.rst:899
msgid "Size of the uncompressed file."
msgstr "未壓縮檔案的大小。"

#: ../../library/zipfile.rst:906
msgid "Command-Line Interface"
msgstr "命令列介面"

#: ../../library/zipfile.rst:908
msgid ""
"The :mod:`zipfile` module provides a simple command-line interface to "
"interact with ZIP archives."
msgstr ""
":mod:`zipfile` 模組提供了一個簡單的命令列介面，用以與 ZIP 封存檔案互動。"

#: ../../library/zipfile.rst:911
msgid ""
"If you want to create a new ZIP archive, specify its name after the :option:"
"`-c` option and then list the filename(s) that should be included:"
msgstr ""
"如果你想建立一個新的 ZIP 封存檔案，請在 :option:`-c` 選項後指定其名稱，然後列"
"出應包含的檔名："

#: ../../library/zipfile.rst:914
msgid "$ python -m zipfile -c monty.zip spam.txt eggs.txt"
msgstr "$ python -m zipfile -c monty.zip spam.txt eggs.txt"

#: ../../library/zipfile.rst:918
msgid "Passing a directory is also acceptable:"
msgstr "傳遞一個目錄也是可以的："

#: ../../library/zipfile.rst:920
msgid "$ python -m zipfile -c monty.zip life-of-brian_1979/"
msgstr "$ python -m zipfile -c monty.zip life-of-brian_1979/"

#: ../../library/zipfile.rst:924
msgid ""
"If you want to extract a ZIP archive into the specified directory, use the :"
"option:`-e` option:"
msgstr ""
"如果你想將一個 ZIP 封存檔案解壓縮到指定的目錄，請使用 :option:`-e` 選項："

#: ../../library/zipfile.rst:927
msgid "$ python -m zipfile -e monty.zip target-dir/"
msgstr "$ python -m zipfile -e monty.zip target-dir/"

#: ../../library/zipfile.rst:931
msgid "For a list of the files in a ZIP archive, use the :option:`-l` option:"
msgstr "要列出 ZIP 封存檔案中的檔案，請使用 :option:`-l` 選項："

#: ../../library/zipfile.rst:933
msgid "$ python -m zipfile -l monty.zip"
msgstr "$ python -m zipfile -l monty.zip"

#: ../../library/zipfile.rst:939
msgid "Command-line options"
msgstr "命令列選項"

#: ../../library/zipfile.rst:944
msgid "List files in a zipfile."
msgstr "列出 zipfile 中的檔案。"

#: ../../library/zipfile.rst:949
msgid "Create zipfile from source files."
msgstr "從來源檔案建立 zipfile。"

#: ../../library/zipfile.rst:954
msgid "Extract zipfile into target directory."
msgstr "將 zipfile 解壓縮到目標目錄。"

#: ../../library/zipfile.rst:959
msgid "Test whether the zipfile is valid or not."
msgstr "測試 zipfile 是否有效。"

#: ../../library/zipfile.rst:963
msgid ""
"Specify encoding of member names for :option:`-l`, :option:`-e` and :option:"
"`-t`."
msgstr "為 :option:`-l`、:option:`-e` 和 :option:`-t` 指定成員名稱的編碼。"

#: ../../library/zipfile.rst:970
msgid "Decompression pitfalls"
msgstr "解壓縮的陷阱"

#: ../../library/zipfile.rst:972
msgid ""
"The extraction in zipfile module might fail due to some pitfalls listed "
"below."
msgstr "zipfile 模組中的解壓縮可能會由於下面列出的一些陷阱而失敗。"

#: ../../library/zipfile.rst:975
msgid "From file itself"
msgstr "來自檔案本身"

#: ../../library/zipfile.rst:977
msgid ""
"Decompression may fail due to incorrect password / CRC checksum / ZIP format "
"or unsupported compression method / decryption."
msgstr ""
"解壓縮可能由於不正確的密碼 / CRC 校驗和 / ZIP 格式或不支援的壓縮方法 / 解密而"
"失敗。"

#: ../../library/zipfile.rst:981
msgid "File System limitations"
msgstr "檔案系統限制"

#: ../../library/zipfile.rst:983
msgid ""
"Exceeding limitations on different file systems can cause decompression "
"failed. Such as allowable characters in the directory entries, length of the "
"file name, length of the pathname, size of a single file, and number of "
"files, etc."
msgstr ""
"超出不同檔案系統的限制可能導致解壓縮失敗。例如目錄條目中允許的字元、檔名長"
"度、路徑名長度、單一檔案的大小以及檔案數量等。"

#: ../../library/zipfile.rst:990
msgid "Resources limitations"
msgstr "資源限制"

#: ../../library/zipfile.rst:992
msgid ""
"The lack of memory or disk volume would lead to decompression failed. For "
"example, decompression bombs (aka `ZIP bomb`_) apply to zipfile library that "
"can cause disk volume exhaustion."
msgstr ""
"記憶體或磁碟空間不足會導致解壓縮失敗。例如，解壓縮炸彈（又稱 `ZIP bomb`_）適"
"用於 zipfile 函式庫，可能導致磁碟空間耗盡。"

#: ../../library/zipfile.rst:997
msgid "Interruption"
msgstr "中斷"

#: ../../library/zipfile.rst:999
msgid ""
"Interruption during the decompression, such as pressing control-C or killing "
"the decompression process may result in incomplete decompression of the "
"archive."
msgstr ""
"在解壓縮過程中斷，例如按下 control-C 或終止解壓縮過程，可能導致封存檔案解壓縮"
"不完整。"

#: ../../library/zipfile.rst:1003
msgid "Default behaviors of extraction"
msgstr "解壓縮的預設行為"

#: ../../library/zipfile.rst:1005
msgid ""
"Not knowing the default extraction behaviors can cause unexpected "
"decompression results. For example, when extracting the same archive twice, "
"it overwrites files without asking."
msgstr ""
"不了解預設的解壓縮行為可能導致非預期的解壓縮結果。例如，當兩次解壓縮同一個封"
"存檔案時，它會不經詢問就覆寫檔案。"
